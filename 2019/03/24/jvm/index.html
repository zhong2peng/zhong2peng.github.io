<!-- build time:Wed Mar 27 2019 00:30:52 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="Blog, Dnight, IT"><link rel="alternate" href="/rss2.xml" title="BiuBiuBiu的博客" type="application/atom+xml"><meta name="description" content="JVM 内存结构Java 虚拟机的内存空间分为 5 个部分：程序计数器Java 虚拟机栈本地方法栈堆方法区JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。程序计数器（PC 寄存器）程序计数器的定义程序计数器是一块较小的内存空间"><meta name="keywords" content="架构诗"><meta property="og:type" content="article"><meta property="og:title" content="jvm"><meta property="og:url" content="https://zhong2peng.github.io/2019/03/24/jvm/index.html"><meta property="og:site_name" content="BiuBiuBiu的博客"><meta property="og:description" content="JVM 内存结构Java 虚拟机的内存空间分为 5 个部分：程序计数器Java 虚拟机栈本地方法栈堆方法区JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。程序计数器（PC 寄存器）程序计数器的定义程序计数器是一块较小的内存空间"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://ww1.sinaimg.cn/large/007rAy9hly1g1gnwm1rxmj30cr0dfwgh.jpg"><meta property="og:image" content="https://ww1.sinaimg.cn/large/007rAy9hly1g1gnthzed1j30gb0gegny.jpg"><meta property="og:updated_time" content="2019-03-26T16:30:10.181Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="jvm"><meta name="twitter:description" content="JVM 内存结构Java 虚拟机的内存空间分为 5 个部分：程序计数器Java 虚拟机栈本地方法栈堆方法区JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。程序计数器（PC 寄存器）程序计数器的定义程序计数器是一块较小的内存空间"><meta name="twitter:image" content="https://ww1.sinaimg.cn/large/007rAy9hly1g1gnwm1rxmj30cr0dfwgh.jpg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://zhong2peng.github.io/2019/03/24/jvm/"><link href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" rel="stylesheet"><title>jvm | BiuBiuBiu的博客</title></head><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/js/src/custom.js"></script><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><a href="https://github.com/zhong2peng"><img width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_darkblue_121621.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1" style="position:absolute;top:0;right:0;border:0"></a><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">BiuBiuBiu的博客</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">我的洪荒之力在燃騒</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://zhong2peng.github.io/2019/03/24/jvm/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Dnight"><meta itemprop="description" content><meta itemprop="image" content="/images/pic.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="BiuBiuBiu的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">jvm</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-24T23:14:09+08:00">2019-03-24 </time><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于&#58;</span> <time title="更新于" itemprop="dateModified" datetime="2019-03-27T00:30:10+08:00">2019-03-27 </time></span><span id="/2019/03/24/jvm/" class="leancloud_visitors" data-flag-title="jvm"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数&#58;</span> <span class="leancloud-visitors-count"></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">6.5k </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">24</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h1><p>Java 虚拟机的内存空间分为 5 个部分：</p><ul><li>程序计数器</li><li>Java 虚拟机栈</li><li>本地方法栈</li><li>堆</li><li>方法区</li></ul><p><img src="https://ww1.sinaimg.cn/large/007rAy9hly1g1gnwm1rxmj30cr0dfwgh.jpg" alt="jvm-memory-structure"></p><p>JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。</p><h2 id="程序计数器（PC-寄存器）"><a href="#程序计数器（PC-寄存器）" class="headerlink" title="程序计数器（PC 寄存器）"></a>程序计数器（PC 寄存器）</h2><h3 id="程序计数器的定义"><a href="#程序计数器的定义" class="headerlink" title="程序计数器的定义"></a>程序计数器的定义</h3><p>程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为<code>Undefined</code>。</p><h3 id="程序计数器的作用"><a href="#程序计数器的作用" class="headerlink" title="程序计数器的作用"></a>程序计数器的作用</h3><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。</li><li>在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。</li></ul><h3 id="程序计数器的特点"><a href="#程序计数器的特点" class="headerlink" title="程序计数器的特点"></a>程序计数器的特点</h3><ul><li>是一块较小的内存空间。</li><li>线程私有，每条线程都有自己的程序计数器。</li><li>生命周期：随着线程的创建而创建，随着线程的结束而销毁。</li><li>是唯一一个不会出现<code>OutOfMemoryError</code>的内存区域。</li></ul><h2 id="Java-虚拟机栈（Java-栈）"><a href="#Java-虚拟机栈（Java-栈）" class="headerlink" title="Java 虚拟机栈（Java 栈）"></a>Java 虚拟机栈（Java 栈）</h2><h3 id="Java-虚拟机栈的定义"><a href="#Java-虚拟机栈的定义" class="headerlink" title="Java 虚拟机栈的定义"></a>Java 虚拟机栈的定义</h3><p>Java 虚拟机栈是描述 Java 方法运行过程的内存模型。</p><p>Java 虚拟机栈会为每一个即将运行的 Java 方法创建一块叫做“栈帧”的区域，用于存放该方法运行过程中的一些信息，如：</p><ul><li>局部变量表</li><li>操作数栈</li><li>动态链接</li><li>方法出口信息</li><li>……</li></ul><p><img src="https://ww1.sinaimg.cn/large/007rAy9hly1g1gnthzed1j30gb0gegny.jpg" alt="jvm-stack"></p><h3 id="压栈出栈过程"><a href="#压栈出栈过程" class="headerlink" title="压栈出栈过程"></a>压栈出栈过程</h3><p>当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。</p><p>Java 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。</p><p>方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。</p><blockquote><p>由于Java 虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题。</p></blockquote><h3 id="Java-虚拟机栈的特点"><a href="#Java-虚拟机栈的特点" class="headerlink" title="Java 虚拟机栈的特点"></a>Java 虚拟机栈的特点</h3><ul><li>局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。</li><li>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。<ul><li>StackOverFlowError 若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。</li><li>OutOfMemoryError 若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。</li></ul></li><li>Java 虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁。</li></ul><blockquote><p>出现 StackOverFlowError 时，内存空间可能还有很多。</p></blockquote><h2 id="本地方法栈（C-栈）"><a href="#本地方法栈（C-栈）" class="headerlink" title="本地方法栈（C 栈）"></a>本地方法栈（C 栈）</h2><h3 id="本地方法栈的定义"><a href="#本地方法栈的定义" class="headerlink" title="本地方法栈的定义"></a>本地方法栈的定义</h3><p>本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。</p><h3 id="栈帧变化过程"><a href="#栈帧变化过程" class="headerlink" title="栈帧变化过程"></a>栈帧变化过程</h3><p>本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。</p><p>方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。</p><blockquote><p>如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。</p></blockquote><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h3><p>堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。</p><h3 id="堆的特点"><a href="#堆的特点" class="headerlink" title="堆的特点"></a>堆的特点</h3><ul><li>线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。</li><li>在虚拟机启动时创建。</li><li>是垃圾回收的主要场所。</li><li>进一步可分为：新生代(Eden区 From Survior To Survivor)、老年代。</li></ul><p>不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。</p><p>堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出 OutOfMemoryError 异常。</p><blockquote><p>Java 堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。</p></blockquote><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="方法区的定义"><a href="#方法区的定义" class="headerlink" title="方法区的定义"></a>方法区的定义</h3><p>Java 虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息：</p><ul><li>已经被虚拟机加载的类信息</li><li>常量</li><li>静态变量</li><li>即时编译器编译后的代码</li></ul><h3 id="方法区的特点"><a href="#方法区的特点" class="headerlink" title="方法区的特点"></a>方法区的特点</h3><ul><li>线程共享。 方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。</li><li>永久代。 方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。</li><li>内存回收效率低。 方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载。</li><li>Java 虚拟机规范对方法区的要求比较宽松。 和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾回收。</li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中。</p><p>当类被 Java 虚拟机加载后， .class 文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如 String 类的 intern() 方法就能在运行期间向常量池中添加字符串常量。</p><h2 id="直接内存（堆外内存）"><a href="#直接内存（堆外内存）" class="headerlink" title="直接内存（堆外内存）"></a>直接内存（堆外内存）</h2><p>直接内存是除 Java 虚拟机之外的内存，但也可能被 Java 使用。</p><h3 id="操作直接内存"><a href="#操作直接内存" class="headerlink" title="操作直接内存"></a>操作直接内存</h3><p>在 NIO 中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的<code>DirectByteBuffer</code>对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。</p><p>直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。</p><h3 id="直接内存与堆内存比较"><a href="#直接内存与堆内存比较" class="headerlink" title="直接内存与堆内存比较"></a>直接内存与堆内存比较</h3><ul><li>直接内存申请空间耗费更高的性能</li><li>直接内存读取 IO 的性能要优于普通的堆内存。</li><li>直接内存作用链： 本地 IO -&gt; 直接内存 -&gt; 本地 IO</li><li>堆内存作用链：本地 IO -&gt; 直接内存 -&gt; 非直接内存 -&gt; 直接内存 -&gt; 本地 IO</li></ul><blockquote><p>服务器管理员在配置虚拟机参数时，会根据实际内存设置<code>-Xmx</code>等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现<code>OutOfMemoryError</code>异常。</p></blockquote><h1 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h1><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>young区</p><p>1.Serial</p><p>关注点：stw的时间 复制算法 STW</p><p>2.ParNew</p><p>关注点：stw的时间 Serial的多线程版本 复制算法 STW</p><p>参数 -XX:ParallelGCThreads 并行线程数</p><p>3.Parallel Scavenge</p><p>关注点：达到一个可控制的吞吐量（吞吐量优先） 复制算法<br>所谓吞吐量就是CPU运行用户代码的时间和CPU消耗的时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)。</p><p>Paralled Scavenge 收集器提供了两个参数用于精确控制吞吐量。分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis ,以及直接设置吞吐量大小的-XX：GCTimeRatio 参数。</p><p>参数<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis </span><br><span class="line">-XX:GCTimeRatio</span><br><span class="line">-XX:+UseAdaptiveSizePolicy 自适应调节策略</span><br></pre></td></tr></table></figure><p></p><p>old区</p><p>1.Serial Old</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Serial的老年代版本 </span><br><span class="line">JDK1.5之前可搭配Parallel Scavenge使用</span><br><span class="line">在CMS发生Concurrent mode failure时使用</span><br><span class="line">Mark-Compact</span><br></pre></td></tr></table></figure><p>2.Parallel Old<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Parallel Scavenge的老年代版本</span><br><span class="line">JDK1.6出现 搭配Parallel Scavenge使用</span><br><span class="line">Mark-Compact</span><br></pre></td></tr></table></figure><p></p><p>3.CMS<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">Mark-Sweep</span><br><span class="line">过程：初始标记 并发标记 重新标记 并发清除</span><br><span class="line">初始标记和重新标记会STW</span><br><span class="line">耗时最长是并发标记和并发清除</span><br><span class="line">默认回收线程数：CMS默认启动的回收线程数目是 (ParallelGCThreads + 3)/4)，可以通过-XX:ParallelCMSThreads=20来设定</span><br><span class="line"></span><br><span class="line">优点：并发低停顿</span><br><span class="line">缺点：</span><br><span class="line">1、对CPU资源非常敏感 </span><br><span class="line">占用部分线程（CPU资源）导致应用程序变慢，吞吐量降低</span><br><span class="line">默认线程数=（CPU数量+3）/4</span><br><span class="line">2、无法处理浮动垃圾，可能出现Concurrent mode failure而导致另一次fullGC的产生</span><br><span class="line">参数-XX:CMSInitiatingOccupancyFraction默认68% CMS触发百分比，CMS执行期间，预留空间无法满足，就会出现Concurrent mode failure失败，启动后备SerialOld的方案，停顿时间更长了。（所以CMSInitiatingOccupancyFraction不能设置的过大）</span><br><span class="line">3、内存碎片</span><br><span class="line">参数-XX:+UseCMSCompactAtFullCollection(停顿时间加长) 默认开启</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction(执行多少次不进行碎片整理的FullGC后进行一次带压缩的)</span><br><span class="line"></span><br><span class="line">其他参数</span><br><span class="line">初始标记的并行化-XX:+CMSParallelInitialMarkEnabled</span><br><span class="line">为了减少第二次暂停的时间，开启并行remark: -XX:+CMSParallelRemarkEnabled,如果remark还是过长的话，可以开启-XX:+CMSScavengeBeforeRemark（在CMS GC前启动一次ygc，目的在于减少old gen对ygc gen的引用，降低remark时的开销-----一般CMS的GC耗时 80%都在remark阶段）</span><br><span class="line"></span><br><span class="line">为了避免Perm区满引起的full gc，建议开启CMS回收Perm区选项：</span><br><span class="line">+CMSPermGenSweepingEnabled -XX:+CMSClassUnloadingEnabled</span><br><span class="line"></span><br><span class="line">-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。</span><br><span class="line">-XX:+UseParNewGC:设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</span><br></pre></td></tr></table></figure><p></p><p>G1收集器</p><h2 id="收集器组合开关选项"><a href="#收集器组合开关选项" class="headerlink" title="收集器组合开关选项"></a>收集器组合开关选项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC Serial+SerialOld</span><br><span class="line">-XX:+UseParNewGC ParNew+SerialOld</span><br><span class="line">-XX:+UseParallelGC ParallelScavenge+SerialOld </span><br><span class="line">-XX:+UseConcMarkSweepGC ParNew+CMS+SerialOld  FullGC算法：单线程的Mark Sweep Compact(MSC)</span><br><span class="line">-XX:+UseParallelOldGC ParallelScavenge+Parallel Old  FullGC算法：PS MarkSweep</span><br></pre></td></tr></table></figure><h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">垃圾回收参数</span><br><span class="line">-Xnoclassgc 是否对类进行回收</span><br><span class="line">-verbose:class -XX:+TraceClassUnloading 查看类加载和卸载信息</span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio Eden和其中一个survivor的比值</span><br><span class="line">-XX:PretenureSizeThreshold 大对象进入老年代的阈值，Serial和ParNew生效</span><br><span class="line">-XX:MaxTenuringThreshold 晋升老年代的对象年龄，默认15, CMS默认是4</span><br><span class="line">-XX:HandlePromotionFailure 老年代担保</span><br><span class="line">-XX:+UseAdaptiveSizePolicy动态调整Java堆中各个区域大小和进入老年代年龄</span><br><span class="line">-XX:ParallelGCThreads 并行回收的线程数</span><br><span class="line">-XX:MaxGCPauseMillis Parallel Scavenge参数，设置GC的最大停顿时间</span><br><span class="line">-XX:GCTimeRatio  Parallel Scavenge参数，GC时间占总时间的比率，默认99%，即1%的GC时间</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction，old区触发cms阈值，默认68%</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection(CMS完成后是否进行一次碎片整理，停顿时间加长)</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction(执行多少次不进行碎片整理的FullGC后进行一次带压缩的)</span><br><span class="line">-XX:+ScavengeBeforeFullGC，在fullgc前触发一次minorGC</span><br><span class="line"></span><br><span class="line">垃圾回收统计信息</span><br><span class="line">-XX:+PrintGC 输出GC日志</span><br><span class="line">-verbose:gc等同于上面那个</span><br><span class="line">-XX:+PrintGCDetails 输出GC的详细日志</span><br><span class="line"></span><br><span class="line">堆大小设置</span><br><span class="line">-Xmx:最大堆大小</span><br><span class="line">-Xms:初始堆大小(最小内存值)</span><br><span class="line">-Xmn:年轻代大小</span><br><span class="line">-XX:NewSize和-XX:MaxNewSize 新生代大小</span><br><span class="line">-XX:SurvivorRatio:3 意思是年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</span><br><span class="line">-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5</span><br><span class="line">-Xss栈容量 默认256k</span><br><span class="line">-XX:PermSize永久代初始值</span><br><span class="line">-XX:MaxPermSize 永久代最大值</span><br></pre></td></tr></table></figure><p>生产环境参数配置(CMS-GC)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Java &lt; 8</span><br><span class="line">    -server</span><br><span class="line">    -Xms&lt;heap size&gt;[g|m|k] -Xmx&lt;heap size&gt;[g|m|k]</span><br><span class="line">    -XX:PermSize=&lt;perm gen size&gt;[g|m|k] -XX:MaxPermSize=&lt;perm gen size&gt;[g|m|k]</span><br><span class="line">    -Xmn&lt;young size&gt;[g|m|k]</span><br><span class="line">    -XX:+DisableExplicitGC</span><br><span class="line">    -XX:SurvivorRatio=&lt;ratio&gt;</span><br><span class="line">    -XX:+UseConcMarkSweepGC </span><br><span class="line">    -XX:+CMSParallelRemarkEnabled</span><br><span class="line">    -XX:+CMSScavengeBeforeRemark</span><br><span class="line">    -XX:+UseCMSInitiatingOccupancyOnly </span><br><span class="line">    -XX:CMSInitiatingOccupancyFraction=&lt;percent&gt;</span><br><span class="line">    -XX:+PrintGCDateStamps -verbose:gc -XX:+PrintGCDetails -Xloggc:&quot;&lt;path to log&gt;&quot;</span><br><span class="line">    -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M</span><br><span class="line">    -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=&lt;path to dump&gt;`date`.hprof</span><br><span class="line">    -Dsun.net.inetaddr.ttl=&lt;TTL in seconds&gt;</span><br><span class="line">    -Djava.rmi.server.hostname=&lt;external IP&gt;</span><br><span class="line">    -Dcom.sun.management.jmxremote.port=&lt;port&gt; </span><br><span class="line">    -Dcom.sun.management.jmxremote.authenticate=false </span><br><span class="line">    -Dcom.sun.management.jmxremote.ssl=false</span><br><span class="line"></span><br><span class="line">Java &gt;= 8</span><br><span class="line">    -server</span><br><span class="line">    -Xms&lt;heap size&gt;[g|m|k] -Xmx&lt;heap size&gt;[g|m|k]</span><br><span class="line">    -XX:MaxMetaspaceSize=&lt;metaspace size&gt;[g|m|k]</span><br><span class="line">    -Xmn&lt;young size&gt;[g|m|k]</span><br><span class="line">    -XX:+DisableExplicitGC</span><br><span class="line">    -XX:SurvivorRatio=&lt;ratio&gt;</span><br><span class="line">    -XX:+UseConcMarkSweepGC </span><br><span class="line">    -XX:+CMSParallelRemarkEnabled</span><br><span class="line">    -XX:+CMSScavengeBeforeRemark</span><br><span class="line">    -XX:+UseCMSInitiatingOccupancyOnly</span><br><span class="line">    -XX:CMSInitiatingOccupancyFraction=&lt;percent&gt;</span><br><span class="line">    -XX:+PrintGCDateStamps -verbose:gc -XX:+PrintGCDetails -Xloggc:&quot;&lt;path to log&gt;&quot;</span><br><span class="line">    -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M</span><br><span class="line">    -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=&lt;path to dump&gt;`date`.hprof</span><br><span class="line">    -Dsun.net.inetaddr.ttl=&lt;TTL in seconds&gt;</span><br><span class="line">    -Djava.rmi.server.hostname=&lt;external IP&gt;</span><br><span class="line">    -Dcom.sun.management.jmxremote.port=&lt;port&gt; </span><br><span class="line">    -Dcom.sun.management.jmxremote.authenticate=false </span><br><span class="line">    -Dcom.sun.management.jmxremote.ssl=false</span><br></pre></td></tr></table></figure><h2 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DefNew：Serial收集器新生代名称 - Tenured - Perm</span><br><span class="line">ParNew：ParNew收集器新生代名称 - </span><br><span class="line">PSYoungGen：Parallel Scavenge收集器新生代名称</span><br></pre></td></tr></table></figure><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><ul><li>GC的时间足够的小</li><li>GC的次数足够的少</li><li><p>发生Full GC的周期足够的长</p><p>前两个目前是相悖的，要想GC时间小必须要一个更小的堆，要保证GC次数足够少，必须保证一个更大的堆，我们只能取其平衡。</p></li></ul><p>（1）针对JVM堆的设置，一般可以通过-Xms -Xmx限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，我们通常把最大、最小设置为相同的值</p><p>（2）年轻代和年老代将根据默认的比例（1：2）分配堆内存，可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代，比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小。-XX:PermSize，-XX:MaxPermSize设置为一样防止老年代收缩。<br>-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5<br>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</p><p>（3）年轻代和年老代设置多大才算合理？这个我问题毫无疑问是没有答案的，否则也就不会有调优。我们观察一下二者大小变化有哪些影响<br>年轻代老年代设置：整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐年轻代配置为整个堆的3/8。</p><ul><li>更大的年轻代必然导致更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC</li><li>更小的年轻代必然导致更大年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率</li><li>如何选择应该依赖应用程序对象生命周期的分布情况：如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。但很多应用都没有这样明显的特性，在抉择时应该根据以下两点：（A）本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理 （B）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间</li></ul><p>（4）在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC ，默认为Serial收集</p><p>（5）线程堆栈的设置：每个线程默认会开启1M的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般256K就足用。理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。 -Xss256k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p><p>（6）可以通过下面的参数打Heap Dump信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:HeapDumpPath</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-Xloggc:/usr/aaa/dump/heap_trace.txt</span><br><span class="line">通过下面参数可以控制OutOfMemoryError时打印堆的信息</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure><p>注：通过分析dump文件可以发现，每个1小时都会发生一次Full GC，经过多方求证，只要在JVM中开启了JMX服务，JMX将会1小时执行一次Full GC以清除引用.</p><h2 id="性能分析工具"><a href="#性能分析工具" class="headerlink" title="性能分析工具"></a>性能分析工具</h2><p>jps<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-m 主类的参数 </span><br><span class="line">-l 主类的全名，如果执行的是jar包，输出jar路径</span><br><span class="line">-v 虚拟机参数</span><br></pre></td></tr></table></figure><p></p><p>jstat<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">监视虚拟机运行状态信息，包括类装载、GC、运行期编译（JIT）</span><br><span class="line">用于输出java程序内存使用情况，包括新生代、老年代、元数据区容量、垃圾回收情况</span><br><span class="line"> jstat -gcutil 52670 2000 5 进程号 2s输出一次一共5次</span><br><span class="line"></span><br><span class="line">S0：幸存1区当前使用比例</span><br><span class="line">S1：幸存2区当前使用比例</span><br><span class="line">E：伊甸园区使用比例</span><br><span class="line">O：老年代使用比例</span><br><span class="line">M：元数据区使用比例</span><br><span class="line">CCS：压缩使用比例</span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line">YGCT：年轻代垃圾回收消耗时间</span><br><span class="line">FGC：老年代垃圾回收次数</span><br><span class="line">FGCT：老年代垃圾回收消耗时间</span><br><span class="line">GCT：垃圾回收消耗总时间</span><br></pre></td></tr></table></figure><p></p><p>jmap<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jmap：用于生成堆转储快照。一般称为dump或heapdump文件。</span><br><span class="line">jmap -histo 3618</span><br><span class="line">上述命令打印出进程ID为3618的内存情况，包括有哪些对象，对象的数量。但我们常用的方式是将指定进程的内存heap输出到外              部文件，再由专门的heap分析工具进行分析,例如mat（Memory Analysis Tool），所以我们常用的命令是：</span><br><span class="line">jmap -dump:live,format=b,file=heap.hprof 3618</span><br><span class="line">-F 强制生成dump快照</span><br></pre></td></tr></table></figure><p></p><p>jstack<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jstack：用户输出虚拟机当前时刻的线程快照，常用于定位因为某些线程问题造成的故障或性能问题。一般称为threaddump文件。</span><br><span class="line">参数</span><br><span class="line">-F当正常输出没有响应的时候强制打印栈信息，一般情况不需要使用</span><br><span class="line">-l长列表. 打印关于锁的附加信息，一般情况不需要使用</span><br><span class="line">-m 如果调用本地方法的话，可打印c/c++的堆栈</span><br></pre></td></tr></table></figure><p></p><p>jinfo</p><p>查看和修改虚拟机参数</p><p>可视化工具<br>JConsole Java监视与管理控制台<br>VisualVM 多合一故障处理工具</p><p>Java Class文件类型前缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Element Type        Encoding</span><br><span class="line">boolean             Z</span><br><span class="line">byte                B</span><br><span class="line">char                C</span><br><span class="line">double              D</span><br><span class="line">float               F</span><br><span class="line">int                 I</span><br><span class="line">long                J</span><br><span class="line">short               S </span><br><span class="line">class or interface  Lclassname;</span><br><span class="line">[L代表了相应类型数组嵌套的层数</span><br></pre></td></tr></table></figure><h2 id="内存泄漏及解决方法"><a href="#内存泄漏及解决方法" class="headerlink" title="内存泄漏及解决方法"></a>内存泄漏及解决方法</h2><p>1.系统崩溃前的一些现象：</p><p>每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，FullGC的时间也有之前的0.5s延长到4、5s</p><p>FullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC</p><p>年老代的内存越来越大并且每次FullGC后年老代没有内存被释放</p><p>之后系统会无法响应新的请求，逐渐到达OutOfMemoryError的临界值。</p><p>2.生成堆的dump文件<br>通过JMX的MBean生成当前的Heap信息，大小为一个3G（整个堆的大小）的hprof文件，如果没有启动JMX可以通过Java的jmap命令来生成该文件。</p><p>3.分析dump文件</p><p>下面要考虑的是如何打开这个3G的堆信息文件，显然一般的Window系统没有这么大的内存，必须借助高配置的Linux。当然我们可以借助X-Window把Linux上的图形导入到Window。我们考虑用下面几种工具打开该文件：</p><p>1.Visual VM<br>2.IBM HeapAnalyzer<br>3.JDK 自带的Hprof工具</p><p>使用这些工具时为了确保加载速度，建议设置最大内存为6G。使用后发现，这些工具都无法直观地观察到内存泄漏，Visual VM虽能观察到对象大小，但看不到调用堆栈；HeapAnalyzer虽然能看到调用堆栈，却无法正确打开一个3G的文件。因此，我们又选用了Eclipse专门的静态内存分析工具：Mat。</p><p>4.分析内存泄漏</p><p>通过Mat我们能清楚地看到，哪些对象被怀疑为内存泄漏，哪些对象占的空间最大及对象的调用关系。针对本案，在ThreadLocal中有很多的JbpmContext实例，经过调查是JBPM的Context没有关闭所致。</p><p>另，通过Mat或JMX我们还可以分析线程状态，可以观察到线程被阻塞在哪个对象上，从而判断系统的瓶颈。</p><p>5.回归问题</p><p>Q：为什么崩溃前垃圾回收的时间越来越长？</p><p>A:根据内存模型和垃圾回收算法，垃圾回收分两部分：内存标记、清除（复制），标记部分只要内存大小固定，时间是不变的，变的是复制部分，因为每次垃圾回收都有一些回收不掉的内存，所以增加了复制量，导致时间延长。所以，垃圾回收的时间也可以作为判断内存泄漏的依据</p><p>Q：为什么Full GC的次数越来越多？</p><p>A：因此内存的积累，逐渐耗尽了年老代的内存，导致新对象分配没有更多的空间，从而导致频繁的垃圾回收</p><p>Q:为什么年老代占用的内存越来越大？</p><p>A:因为年轻代的内存无法被回收，越来越多地被Copy到年老代</p><h2 id="调优方法"><a href="#调优方法" class="headerlink" title="调优方法"></a>调优方法</h2><p>一切都是为了这一步，调优，在调优之前，我们需要记住下面的原则：</p><p>1、多数的Java应用不需要在服务器上进行GC优化；</p><p>2、多数导致GC问题的Java应用，都不是因为我们参数设置错误，而是代码问题；</p><p>3、在应用上线之前，先考虑将机器的JVM参数设置到最优（最适合）</p><p>4、减少创建对象的数量；</p><p>5、减少使用全局变量和大对象；</p><p>6、GC优化是到最后不得已才采用的手段；</p><p>7、在实际使用中，分析GC情况优化代码比优化GC参数要多得多；</p><p>GC优化的目的有两个</p><p>1、将转移到老年代的对象数量降低到最小；</p><p>2、减少full GC的执行时间；</p><p>为了达到上面的目的，一般地，你需要做的事情有：</p><p>1、减少使用全局变量和大对象；</p><p>2、调整新生代的大小到最合适；</p><p>3、设置老年代的大小为最合适；</p><p>4、选择合适的GC收集器</p></div><div><div style="text-align:center;color:#ccc;font-size:14px">------ 本文结束<i class="fa fa-paw"></i>感谢您的阅读 ------</div></div><div></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/03/22/rabbitmq/" rel="next" title="rabbitmq"><i class="fa fa-chevron-left"></i> rabbitmq</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/03/25/java面试题/" rel="prev" title="java面试题梳理">java面试题梳理 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"><div class="jiathis_style"><span class="jiathis_txt">分享到：</span> <a class="jiathis_button_fav">收藏夹</a> <a class="jiathis_button_copy">复制网址</a> <a class="jiathis_button_email">邮件</a> <a class="jiathis_button_weixin">微信</a> <a class="jiathis_button_qzone">QQ空间</a> <a class="jiathis_button_tqq">腾讯微博</a> <a class="jiathis_button_douban">豆瓣</a> <a class="jiathis_button_share">一键分享</a> <a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a> <a class="jiathis_counter_style"></a></div><script type="text/javascript">var jiathis_config={data_track_clickback:!0,summary:"",shortUrl:!1,hideMore:!1}</script><script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/pic.jpg" alt="Dnight"><p class="site-author-name" itemprop="name">Dnight</p><p class="site-description motion-element" itemprop="description">菜鸡之路</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">1</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">5</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/rss2.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zhong2peng" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://weibo.com/3760833981" target="_blank" title="微博"><i class="fa fa-fw fa-weibo"></i>微博</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://www.tianxiaobo.com/" title="田小波" target="_blank">田小波</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM-内存结构"><span class="nav-number">1.</span> <span class="nav-text">JVM 内存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#程序计数器（PC-寄存器）"><span class="nav-number">1.1.</span> <span class="nav-text">程序计数器（PC 寄存器）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序计数器的定义"><span class="nav-number">1.1.1.</span> <span class="nav-text">程序计数器的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序计数器的作用"><span class="nav-number">1.1.2.</span> <span class="nav-text">程序计数器的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序计数器的特点"><span class="nav-number">1.1.3.</span> <span class="nav-text">程序计数器的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-虚拟机栈（Java-栈）"><span class="nav-number">1.2.</span> <span class="nav-text">Java 虚拟机栈（Java 栈）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-虚拟机栈的定义"><span class="nav-number">1.2.1.</span> <span class="nav-text">Java 虚拟机栈的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#压栈出栈过程"><span class="nav-number">1.2.2.</span> <span class="nav-text">压栈出栈过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-虚拟机栈的特点"><span class="nav-number">1.2.3.</span> <span class="nav-text">Java 虚拟机栈的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本地方法栈（C-栈）"><span class="nav-number">1.3.</span> <span class="nav-text">本地方法栈（C 栈）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#本地方法栈的定义"><span class="nav-number">1.3.1.</span> <span class="nav-text">本地方法栈的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈帧变化过程"><span class="nav-number">1.3.2.</span> <span class="nav-text">栈帧变化过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆"><span class="nav-number">1.4.</span> <span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#堆的定义"><span class="nav-number">1.4.1.</span> <span class="nav-text">堆的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆的特点"><span class="nav-number">1.4.2.</span> <span class="nav-text">堆的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法区"><span class="nav-number">1.5.</span> <span class="nav-text">方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法区的定义"><span class="nav-number">1.5.1.</span> <span class="nav-text">方法区的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法区的特点"><span class="nav-number">1.5.2.</span> <span class="nav-text">方法区的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时常量池"><span class="nav-number">1.5.3.</span> <span class="nav-text">运行时常量池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#直接内存（堆外内存）"><span class="nav-number">1.6.</span> <span class="nav-text">直接内存（堆外内存）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#操作直接内存"><span class="nav-number">1.6.1.</span> <span class="nav-text">操作直接内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#直接内存与堆内存比较"><span class="nav-number">1.6.2.</span> <span class="nav-text">直接内存与堆内存比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java虚拟机"><span class="nav-number">2.</span> <span class="nav-text">Java虚拟机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集器"><span class="nav-number">2.1.</span> <span class="nav-text">垃圾收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#收集器组合开关选项"><span class="nav-number">2.2.</span> <span class="nav-text">收集器组合开关选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM参数"><span class="nav-number">2.3.</span> <span class="nav-text">JVM参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#理解GC日志"><span class="nav-number">2.4.</span> <span class="nav-text">理解GC日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM调优"><span class="nav-number">2.5.</span> <span class="nav-text">JVM调优</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能分析工具"><span class="nav-number">2.6.</span> <span class="nav-text">性能分析工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄漏及解决方法"><span class="nav-number">2.7.</span> <span class="nav-text">内存泄漏及解决方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调优方法"><span class="nav-number">2.8.</span> <span class="nav-text">调优方法</span></a></li></ol></li></ol></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Dnight</span></div><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/three/three.min.js"></script><script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script>AV.initialize("oJM2KP9949u790dn1g3FVavc-gzGzoHsz","gPtQOls39Fh76goU0K9oj5tw")</script><script>function showTime(e){var t=new AV.Query(e),n=[],o=$(".leancloud_visitors");o.each(function(){n.push($(this).attr("id").trim())}),t.containedIn("url",n),t.find().done(function(e){var t=".leancloud-visitors-count";if(0===e.length)return void o.find(t).text(0);for(var i=0;i<e.length;i++){var r=e[i],s=r.get("url"),l=r.get("time"),c=document.getElementById(s);$(c).find(t).text(l)}for(var i=0;i<n.length;i++){var s=n[i],c=document.getElementById(s),u=$(c).find(t);""==u.text()&&u.text(0)}}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var t=$(".leancloud_visitors"),n=t.attr("id").trim(),o=t.attr("data-flag-title").trim(),i=new AV.Query(e);i.equalTo("url",n),i.find({success:function(t){if(t.length>0){var i=t[0];i.fetchWhenSave(!0),i.increment("time"),i.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var r=new e,s=new AV.ACL;s.setPublicReadAccess(!0),s.setPublicWriteAccess(!0),r.setACL(s),r.set("title",o),r.set("url",n),r.set("time",1),r.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):$(".post-title-link").length>1&&showTime(e)})</script></body></html><!-- rebuild by neat -->