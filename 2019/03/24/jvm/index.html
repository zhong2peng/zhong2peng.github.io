<!-- build time:Sun Mar 31 2019 23:16:02 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="Blog, Dnight, IT"><link rel="alternate" href="/rss2.xml" title="BiuBiuBiu的博客" type="application/atom+xml"><meta name="description" content="JVM 内存结构Java 虚拟机的内存空间分为 5 个部分：程序计数器Java 虚拟机栈本地方法栈堆方法区JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。程序计数器（PC 寄存器）程序计数器的定义程序计数器是一块较小的内存空间"><meta name="keywords" content="架构诗"><meta property="og:type" content="article"><meta property="og:title" content="jvm"><meta property="og:url" content="https://zhong2peng.github.io/2019/03/24/jvm/index.html"><meta property="og:site_name" content="BiuBiuBiu的博客"><meta property="og:description" content="JVM 内存结构Java 虚拟机的内存空间分为 5 个部分：程序计数器Java 虚拟机栈本地方法栈堆方法区JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。程序计数器（PC 寄存器）程序计数器的定义程序计数器是一块较小的内存空间"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://ww1.sinaimg.cn/large/007rAy9hly1g1gnwm1rxmj30cr0dfwgh.jpg"><meta property="og:image" content="https://ww1.sinaimg.cn/large/007rAy9hly1g1gnthzed1j30gb0gegny.jpg"><meta property="og:image" content="https://ww1.sinaimg.cn/large/007rAy9hly1g1hrj6xi7lj30cy07enaq.jpg"><meta property="og:image" content="https://ww1.sinaimg.cn/large/007rAy9hly1g1hrjtir9xj30iw09c76n.jpg"><meta property="og:image" content="https://ww1.sinaimg.cn/large/007rAy9hly1g1hrkidkzoj30iw09cwgt.jpg"><meta property="og:updated_time" content="2019-03-31T14:35:16.431Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="jvm"><meta name="twitter:description" content="JVM 内存结构Java 虚拟机的内存空间分为 5 个部分：程序计数器Java 虚拟机栈本地方法栈堆方法区JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。程序计数器（PC 寄存器）程序计数器的定义程序计数器是一块较小的内存空间"><meta name="twitter:image" content="https://ww1.sinaimg.cn/large/007rAy9hly1g1gnwm1rxmj30cr0dfwgh.jpg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://zhong2peng.github.io/2019/03/24/jvm/"><link href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" rel="stylesheet"><title>jvm | BiuBiuBiu的博客</title></head><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/js/src/custom.js"></script><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><a href="https://github.com/zhong2peng"><img width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_darkblue_121621.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1" style="position:absolute;top:0;right:0;border:0"></a><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">BiuBiuBiu的博客</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">我的洪荒之力在燃騒</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://zhong2peng.github.io/2019/03/24/jvm/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Dnight"><meta itemprop="description" content><meta itemprop="image" content="/images/pic.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="BiuBiuBiu的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">jvm</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-24T23:14:09+08:00">2019-03-24 </time><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于&#58;</span> <time title="更新于" itemprop="dateModified" datetime="2019-03-31T22:35:16+08:00">2019-03-31 </time></span><span id="/2019/03/24/jvm/" class="leancloud_visitors" data-flag-title="jvm"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数&#58;</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-divider">|</span> <span class="page-pv"><i class="fa fa-file-o"></i> <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">10.2k </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">36</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h1><p>Java 虚拟机的内存空间分为 5 个部分：</p><ul><li>程序计数器</li><li>Java 虚拟机栈</li><li>本地方法栈</li><li>堆</li><li>方法区</li></ul><p><img src="https://ww1.sinaimg.cn/large/007rAy9hly1g1gnwm1rxmj30cr0dfwgh.jpg" alt="jvm-memory-structure"></p><p>JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。</p><h2 id="程序计数器（PC-寄存器）"><a href="#程序计数器（PC-寄存器）" class="headerlink" title="程序计数器（PC 寄存器）"></a>程序计数器（PC 寄存器）</h2><h3 id="程序计数器的定义"><a href="#程序计数器的定义" class="headerlink" title="程序计数器的定义"></a>程序计数器的定义</h3><p>程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为<code>Undefined</code>。</p><h3 id="程序计数器的作用"><a href="#程序计数器的作用" class="headerlink" title="程序计数器的作用"></a>程序计数器的作用</h3><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。</li><li>在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。</li></ul><h3 id="程序计数器的特点"><a href="#程序计数器的特点" class="headerlink" title="程序计数器的特点"></a>程序计数器的特点</h3><ul><li>是一块较小的内存空间。</li><li>线程私有，每条线程都有自己的程序计数器。</li><li>生命周期：随着线程的创建而创建，随着线程的结束而销毁。</li><li>是唯一一个不会出现<code>OutOfMemoryError</code>的内存区域。</li></ul><h2 id="Java-虚拟机栈（Java-栈）"><a href="#Java-虚拟机栈（Java-栈）" class="headerlink" title="Java 虚拟机栈（Java 栈）"></a>Java 虚拟机栈（Java 栈）</h2><h3 id="Java-虚拟机栈的定义"><a href="#Java-虚拟机栈的定义" class="headerlink" title="Java 虚拟机栈的定义"></a>Java 虚拟机栈的定义</h3><p>Java 虚拟机栈是描述 Java 方法运行过程的内存模型。</p><p>Java 虚拟机栈会为每一个即将运行的 Java 方法创建一块叫做“栈帧”的区域，用于存放该方法运行过程中的一些信息，如：</p><ul><li>局部变量表</li><li>操作数栈</li><li>动态链接</li><li>方法出口信息</li><li>……</li></ul><p><img src="https://ww1.sinaimg.cn/large/007rAy9hly1g1gnthzed1j30gb0gegny.jpg" alt="jvm-stack"></p><h3 id="压栈出栈过程"><a href="#压栈出栈过程" class="headerlink" title="压栈出栈过程"></a>压栈出栈过程</h3><p>当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。</p><p>Java 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。</p><p>方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。</p><blockquote><p>由于Java 虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题。</p></blockquote><h3 id="Java-虚拟机栈的特点"><a href="#Java-虚拟机栈的特点" class="headerlink" title="Java 虚拟机栈的特点"></a>Java 虚拟机栈的特点</h3><ul><li>局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。</li><li>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。<ul><li>StackOverFlowError 若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。</li><li>OutOfMemoryError 若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。</li></ul></li><li>Java 虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁。</li></ul><blockquote><p>出现 StackOverFlowError 时，内存空间可能还有很多。</p></blockquote><h2 id="本地方法栈（C-栈）"><a href="#本地方法栈（C-栈）" class="headerlink" title="本地方法栈（C 栈）"></a>本地方法栈（C 栈）</h2><h3 id="本地方法栈的定义"><a href="#本地方法栈的定义" class="headerlink" title="本地方法栈的定义"></a>本地方法栈的定义</h3><p>本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。</p><h3 id="栈帧变化过程"><a href="#栈帧变化过程" class="headerlink" title="栈帧变化过程"></a>栈帧变化过程</h3><p>本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。</p><p>方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。</p><blockquote><p>如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。</p></blockquote><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h3><p>堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。</p><h3 id="堆的特点"><a href="#堆的特点" class="headerlink" title="堆的特点"></a>堆的特点</h3><ul><li>线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。</li><li>在虚拟机启动时创建。</li><li>是垃圾回收的主要场所。</li><li>进一步可分为：新生代(Eden区 From Survior To Survivor)、老年代。</li></ul><p>不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。</p><p>堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出 OutOfMemoryError 异常。</p><blockquote><p>Java 堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。</p></blockquote><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="方法区的定义"><a href="#方法区的定义" class="headerlink" title="方法区的定义"></a>方法区的定义</h3><p>Java 虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息：</p><ul><li>已经被虚拟机加载的类信息</li><li>常量</li><li>静态变量</li><li>即时编译器编译后的代码</li></ul><h3 id="方法区的特点"><a href="#方法区的特点" class="headerlink" title="方法区的特点"></a>方法区的特点</h3><ul><li>线程共享。 方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。</li><li>永久代。 方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。</li><li>内存回收效率低。 方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载。</li><li>Java 虚拟机规范对方法区的要求比较宽松。 和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾回收。</li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中。</p><p>当类被 Java 虚拟机加载后， .class 文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如 String 类的 intern() 方法就能在运行期间向常量池中添加字符串常量。</p><h2 id="直接内存（堆外内存）"><a href="#直接内存（堆外内存）" class="headerlink" title="直接内存（堆外内存）"></a>直接内存（堆外内存）</h2><p>直接内存是除 Java 虚拟机之外的内存，但也可能被 Java 使用。</p><h3 id="操作直接内存"><a href="#操作直接内存" class="headerlink" title="操作直接内存"></a>操作直接内存</h3><p>在 NIO 中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的<code>DirectByteBuffer</code>对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。</p><p>直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。</p><h3 id="直接内存与堆内存比较"><a href="#直接内存与堆内存比较" class="headerlink" title="直接内存与堆内存比较"></a>直接内存与堆内存比较</h3><ul><li>直接内存申请空间耗费更高的性能</li><li>直接内存读取 IO 的性能要优于普通的堆内存。</li><li>直接内存作用链： 本地 IO -&gt; 直接内存 -&gt; 本地 IO</li><li>堆内存作用链：本地 IO -&gt; 直接内存 -&gt; 非直接内存 -&gt; 直接内存 -&gt; 本地 IO</li></ul><blockquote><p>服务器管理员在配置虚拟机参数时，会根据实际内存设置<code>-Xmx</code>等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现<code>OutOfMemoryError</code>异常。</p></blockquote><h1 id="HotSpot-虚拟机对象探秘"><a href="#HotSpot-虚拟机对象探秘" class="headerlink" title="HotSpot 虚拟机对象探秘"></a>HotSpot 虚拟机对象探秘</h1><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在 HotSpot 虚拟机中，对象的内存布局分为以下 3 块区域：</p><ul><li>对象头（Header）</li><li>实例数据（Instance Data）</li><li>对齐填充（Padding）</li></ul><p><img src="https://ww1.sinaimg.cn/large/007rAy9hly1g1hrj6xi7lj30cy07enaq.jpg" alt="object-memory-layout.png"></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头记录了对象在运行过程中所需要使用的一些数据：</p><ul><li>哈希码</li><li>GC 分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程 ID</li><li>偏向时间戳</li></ul><p>对象头可能包含类型指针，通过该指针能确定对象属于哪个类。如果对象是一个数组，那么对象头还会包括数组长度。</p><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>实例数据部分就是成员变量的值，其中包括父类成员变量和本类成员变量。</p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>用于确保对象的总长度为 8 字节的整数倍。</p><p>HotSpot VM 的自动内存管理系统要求对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><blockquote><p>对齐填充并不是必然存在，也没有特别的含义，它仅仅起着占位符的作用。</p></blockquote><h2 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h2><h3 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h3><p>虚拟机在解析<code>.class</code>文件时，若遇到一条 new 指令，首先它会去检查常量池中是否有这个类的符号引用，并且检查这个符号引用所代表的类是否已被加载、解析和初始化过。如果没有，那么必须先执行相应的类加载过程。</p><h3 id="为新生对象分配内存"><a href="#为新生对象分配内存" class="headerlink" title="为新生对象分配内存"></a>为新生对象分配内存</h3><p>对象所需内存的大小在类加载完成后便可完全确定，接下来从堆中划分一块对应大小的内存空间给新的对象。分配堆中内存有两种方式：</p><ul><li><p><strong>指针碰撞</strong><br><br>如果 Java <strong>堆中内存绝对规整</strong>（说明采用的是“<strong>复制算法</strong>”或“<strong>标记整理法</strong>”），空闲内存和已使用内存中间放着一个指针作为分界点指示器，那么分配内存时只需要把指针向空闲内存挪动一段与对象大小一样的距离，这种分配方式称为“<strong>指针碰撞</strong>”。</p></li><li><p><strong>空闲列表</strong><br><br>如果 Java <strong>堆中内存并不规整</strong>，已使用的内存和空闲内存交错（说明采用的是<strong>标记-清除法</strong>，有碎片），此时没法简单进行指针碰撞， VM 必须维护一个列表，记录其中哪些内存块空闲可用。分配之时从空闲列表中找到一块足够大的内存空间划分给对象实例。这种方式称为“<strong>空闲列表</strong>”。</p></li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>分配完内存后，为对象中的成员变量赋上初始值，设置对象头信息，调用对象的构造函数方法进行初始化。</p><p>至此，整个对象的创建过程就完成了。</p><h2 id="对象的访问方式"><a href="#对象的访问方式" class="headerlink" title="对象的访问方式"></a>对象的访问方式</h2><p>所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配的。也就是说在建立一个对象时两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针（引用）而已。 那么根据引用存放的地址类型的不同，对象有不同的访问方式。</p><h3 id="句柄访问方式"><a href="#句柄访问方式" class="headerlink" title="句柄访问方式"></a>句柄访问方式</h3><p>堆中需要有一块叫做“句柄池”的内存空间，句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p><p>引用类型的变量存放的是该对象的句柄地址（reference）。访问对象时，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址找到对象。</p><p><img src="https://ww1.sinaimg.cn/large/007rAy9hly1g1hrjtir9xj30iw09c76n.jpg" alt="handle-access"></p><h3 id="直接指针访问方式"><a href="#直接指针访问方式" class="headerlink" title="直接指针访问方式"></a>直接指针访问方式</h3><p>引用类型的变量直接存放对象的地址，从而不需要句柄池，通过引用能够直接访问对象。但对象所在的内存空间需要额外的策略存储对象所属的类信息的地址。</p><p><img src="https://ww1.sinaimg.cn/large/007rAy9hly1g1hrkidkzoj30iw09cwgt.jpg" alt="direct-pointer"></p><p>需要说明的是，HotSpot 采用第二种方式，即直接指针方式来访问对象，只需要一次寻址操作，所以在性能上比句柄访问方式快一倍。但像上面所说，它需要<strong>额外的策略</strong>来存储对象在方法区中类信息的地址。</p><h1 id="垃圾收集策略与算法"><a href="#垃圾收集策略与算法" class="headerlink" title="垃圾收集策略与算法"></a>垃圾收集策略与算法</h1><p>程序计数器、虚拟机栈、本地方法栈随线程而生，也随线程而灭；栈帧随着方法的开始而入栈，随着方法的结束而出栈。这几个区域的内存分配和回收都具有确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</p><p>而对于 Java 堆和方法区，我们只有在程序运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的正是这部分内存。</p><h2 id="判定对象是否存活"><a href="#判定对象是否存活" class="headerlink" title="判定对象是否存活"></a>判定对象是否存活</h2><p>若一个对象不被任何对象或变量引用，那么它就是无效对象，需要被回收。</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>在对象头维护着一个 counter 计数器，对象被引用一次则计数器 +1；若引用失效则计数器 -1。当计数器为 0 时，就认为该对象无效了。</p><p>引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法。但是主流的 Java 虚拟机里没有选用引用计数算法来管理内存，主要是因为它很难解决对象之间循环引用的问题。</p><blockquote><p>举个栗子👉对象 objA 和 objB 都有字段 instance，令 objA.instance = objB 并且 objB.instance = objA，由于它们互相引用着对方，导致它们的引用计数都不为 0，于是引用计数算法无法通知 GC 收集器回收它们。</p></blockquote><h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p>所有和 GC Roots 直接或间接关联的对象都是有效对象，和 GC Roots 没有关联的对象就是无效对象。</p><p>GC Roots 是指：</p><ul><li>Java 虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中常量引用的对象</li><li>方法区中类静态属性引用的对象</li></ul><p>GC Roots 并不包括堆中对象所引用的对象，这样就不会有循环引用的问题。</p><h2 id="引用的种类"><a href="#引用的种类" class="headerlink" title="引用的种类"></a>引用的种类</h2><p>判定对象是否存活与“引用”有关。在 JDK 1.2 以前，Java 中的引用定义很传统，一个对象只有被引用或者没有被引用两种状态，我们希望能描述这一类对象：当内存空间还足够时，则保留在内存中；如果内存空间在进行垃圾手收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。</p><p>在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为了以下四种。不同的引用类型，主要体现的是对象不同的可达性状态<code>reachable</code>和垃圾收集的影响。</p><h3 id="强引用（Strong-Reference）"><a href="#强引用（Strong-Reference）" class="headerlink" title="强引用（Strong Reference）"></a>强引用（Strong Reference）</h3><p>类似 “Object obj = new Object()” 这类的引用，就是强引用，只要强引用存在，垃圾收集器永远不会回收被引用的对象。但是，如果我们<strong>错误地保持了强引用</strong>，比如：赋值给了 static 变量，那么对象在很长一段时间内不会被回收，会产生内存泄漏。</p><h3 id="软引用（Soft-Reference）"><a href="#软引用（Soft-Reference）" class="headerlink" title="软引用（Soft Reference）"></a>软引用（Soft Reference）</h3><p>软引用是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来<strong>实现内存敏感的缓存</strong>，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><h3 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h3><p>弱引用的<strong>强度比软引用更弱</strong>一些。当 JVM 进行垃圾回收时，<strong>无论内存是否充足，都会回收</strong>被软引用关联的对象。</p><h3 id="虚引用（Phantom-Reference）"><a href="#虚引用（Phantom-Reference）" class="headerlink" title="虚引用（Phantom Reference）"></a>虚引用（Phantom Reference）</h3><p>虚引用也称幽灵引用或者幻影引用，它是<strong>最弱</strong>的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。它仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制。</p><h2 id="回收堆中无效对象"><a href="#回收堆中无效对象" class="headerlink" title="回收堆中无效对象"></a>回收堆中无效对象</h2><p>对于可达性分析中不可达的对象，也并不是没有存活的可能。</p><h3 id="判定-finalize-是否有必要执行"><a href="#判定-finalize-是否有必要执行" class="headerlink" title="判定 finalize() 是否有必要执行"></a>判定 finalize() 是否有必要执行</h3><p>JVM 会判断此对象是否有必要执行 finalize() 方法，如果对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，那么视为“没有必要执行”。那么对象基本上就真的被回收了。</p><p>如果对象被判定为有必要执行 finalize() 方法，那么对象会被放入一个 F-Queue 队列中，虚拟机会以较低的优先级执行这些 finalize()方法，但不会确保所有的 finalize() 方法都会执行结束。如果 finalize() 方法出现耗时操作，虚拟机就直接停止指向该方法，将对象清除。</p><h3 id="对象重生或死亡"><a href="#对象重生或死亡" class="headerlink" title="对象重生或死亡"></a>对象重生或死亡</h3><p>如果在执行 finalize() 方法时，将 this 赋给了某一个引用，那么该对象就重生了。如果没有，那么就会被垃圾收集器清除。</p><blockquote><p>任何一个对象的 finalize() 方法只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize() 方法不会被再次执行，想继续在 finalize() 中自救就失效了。</p></blockquote><h2 id="回收方法区内存"><a href="#回收方法区内存" class="headerlink" title="回收方法区内存"></a>回收方法区内存</h2><p>方法区中存放生命周期较长的类信息、常量、静态变量，每次垃圾收集只有少量的垃圾被清除。方法区中主要清除两种垃圾：</p><ul><li>废弃常量</li><li>无用的类</li></ul><h3 id="判定废弃常量"><a href="#判定废弃常量" class="headerlink" title="判定废弃常量"></a>判定废弃常量</h3><p>只要常量池中的常量不被任何变量或对象引用，那么这些常量就会被清除掉。比如，一个字符串 “bingo” 进入了常量池，但是当前系统没有任何一个 String 对象引用常量池中的 “bingo” 常量，也没有其它地方引用这个字面量，必要的话，”bingo”常量会被清理出常量池。</p><h3 id="判定无用的类"><a href="#判定无用的类" class="headerlink" title="判定无用的类"></a>判定无用的类</h3><p>判定一个类是否是“无用的类”，条件较为苛刻。</p><ul><li>该类的所有对象都已经被清除</li><li>加载该类的 ClassLoader 已经被回收</li><li>该类的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><blockquote><p>一个类被虚拟机加载进方法区，那么在堆中就会有一个代表该类的对象：java.lang.Class。这个对象在类被加载进方法区时创建，在方法区该类被删除时清除。</p></blockquote><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>学会了如何判定无效对象、无用类、废弃常量之后，剩余工作就是回收这些垃圾。常见的垃圾收集算法有以下几个：</p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>判断哪些数据需要清除，并对它们进行标记，然后清除被标记的数据。</p><p>这种方法有两个<strong>不足</strong>：</p><ul><li>效率问题：标记和清除两个过程的效率都不高。</li><li>空间问题：标记清除之后会产生大量不连续的内存碎片，碎片太多可能导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><h3 id="复制算法（新生代）"><a href="#复制算法（新生代）" class="headerlink" title="复制算法（新生代）"></a>复制算法（新生代）</h3><p>为了解决效率问题，“复制”收集算法出现了。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完，需要进行垃圾收集时，就将存活者的对象复制到另一块上面，然后将第一块内存全部清除。这种算法有优有劣：</p><ul><li>优点：不会有内存碎片的问题。</li><li>缺点：内存缩小为原来的一半，浪费空间。</li></ul><p>为了解决空间利用率问题，可以将内存分为三块： Eden、From Survivor、To Survivor，比例是 8:1:1，每次使用 Eden 和其中一块 Survivor。回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才使用的 Survivor 空间。这样只有 10% 的内存被浪费。</p><p>但是我们无法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够，需要依赖其他内存（指老年代）进行分配担保。</p><h4 id="分配担保"><a href="#分配担保" class="headerlink" title="分配担保"></a>分配担保</h4><p>为对象分配内存空间时，如果 Eden+Survivor 中空闲区域无法装下该对象，会触发 MinorGC 进行垃圾收集。但如果 Minor GC 过后依然有超过 10% 的对象存活，这样存活的对象直接通过分配担保机制进入老年代，然后再将新对象存入 Eden 区。</p><h3 id="标记-整理算法（老年代）"><a href="#标记-整理算法（老年代）" class="headerlink" title="标记-整理算法（老年代）"></a>标记-整理算法（老年代）</h3><p>在回收垃圾前，首先将废弃对象做上标记，然后将未标记的对象移到一边，最后清空另一边区域即可。</p><p>这是一种老年代的垃圾收集算法。老年代的对象一般寿命比较长，因此每次垃圾回收会有大量对象存活，如果采用复制算法，每次需要复制大量存活的对象，效率很低。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>根据对象存活周期的不同，将内存划分为几块。一般是把 Java 堆分为新生代和老年代，针对各个年代的特点采用最适当的收集算法。</p><ul><li>新生代：复制算法</li><li>老年代：标记-清除算法、标记-整理算法</li></ul><h1 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h1><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>young区</p><p>1.Serial</p><p>关注点：stw的时间 复制算法 STW</p><p>2.ParNew</p><p>关注点：stw的时间 Serial的多线程版本 复制算法 STW</p><p>参数 -XX:ParallelGCThreads 并行线程数</p><p>3.Parallel Scavenge</p><p>关注点：达到一个可控制的吞吐量（吞吐量优先） 复制算法<br>所谓吞吐量就是CPU运行用户代码的时间和CPU消耗的时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)。</p><p>Paralled Scavenge 收集器提供了两个参数用于精确控制吞吐量。分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis ,以及直接设置吞吐量大小的-XX：GCTimeRatio 参数。</p><p>参数<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis </span><br><span class="line">-XX:GCTimeRatio</span><br><span class="line">-XX:+UseAdaptiveSizePolicy 自适应调节策略</span><br></pre></td></tr></table></figure><p></p><p>old区</p><p>1.Serial Old</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Serial的老年代版本 </span><br><span class="line">JDK1.5之前可搭配Parallel Scavenge使用</span><br><span class="line">在CMS发生Concurrent mode failure时使用</span><br><span class="line">Mark-Compact</span><br></pre></td></tr></table></figure><p>2.Parallel Old<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Parallel Scavenge的老年代版本</span><br><span class="line">JDK1.6出现 搭配Parallel Scavenge使用</span><br><span class="line">Mark-Compact</span><br></pre></td></tr></table></figure><p></p><p>3.CMS<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">Mark-Sweep</span><br><span class="line">过程：初始标记 并发标记 重新标记 并发清除</span><br><span class="line">初始标记和重新标记会STW</span><br><span class="line">耗时最长是并发标记和并发清除</span><br><span class="line">默认回收线程数：CMS默认启动的回收线程数目是 (ParallelGCThreads + 3)/4)，可以通过-XX:ParallelCMSThreads=20来设定</span><br><span class="line"></span><br><span class="line">优点：并发低停顿</span><br><span class="line">缺点：</span><br><span class="line">1、对CPU资源非常敏感 </span><br><span class="line">占用部分线程（CPU资源）导致应用程序变慢，吞吐量降低</span><br><span class="line">默认线程数=（CPU数量+3）/4</span><br><span class="line">2、无法处理浮动垃圾，可能出现Concurrent mode failure而导致另一次fullGC的产生</span><br><span class="line">参数-XX:CMSInitiatingOccupancyFraction默认68% CMS触发百分比，CMS执行期间，预留空间无法满足，就会出现Concurrent mode failure失败，启动后备SerialOld的方案，停顿时间更长了。（所以CMSInitiatingOccupancyFraction不能设置的过大）</span><br><span class="line">3、内存碎片</span><br><span class="line">参数-XX:+UseCMSCompactAtFullCollection(停顿时间加长) 默认开启</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction(执行多少次不进行碎片整理的FullGC后进行一次带压缩的)</span><br><span class="line"></span><br><span class="line">其他参数</span><br><span class="line">初始标记的并行化-XX:+CMSParallelInitialMarkEnabled</span><br><span class="line">为了减少第二次暂停的时间，开启并行remark: -XX:+CMSParallelRemarkEnabled,如果remark还是过长的话，可以开启-XX:+CMSScavengeBeforeRemark（在CMS GC前启动一次ygc，目的在于减少old gen对ygc gen的引用，降低remark时的开销-----一般CMS的GC耗时 80%都在remark阶段）</span><br><span class="line"></span><br><span class="line">为了避免Perm区满引起的full gc，建议开启CMS回收Perm区选项：</span><br><span class="line">+CMSPermGenSweepingEnabled -XX:+CMSClassUnloadingEnabled</span><br><span class="line"></span><br><span class="line">-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。</span><br><span class="line">-XX:+UseParNewGC:设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</span><br></pre></td></tr></table></figure><p></p><p>G1收集器</p><h2 id="收集器组合开关选项"><a href="#收集器组合开关选项" class="headerlink" title="收集器组合开关选项"></a>收集器组合开关选项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC Serial+SerialOld</span><br><span class="line">-XX:+UseParNewGC ParNew+SerialOld</span><br><span class="line">-XX:+UseParallelGC ParallelScavenge+SerialOld </span><br><span class="line">-XX:+UseConcMarkSweepGC ParNew+CMS+SerialOld  FullGC算法：单线程的Mark Sweep Compact(MSC)</span><br><span class="line">-XX:+UseParallelOldGC ParallelScavenge+Parallel Old  FullGC算法：PS MarkSweep</span><br></pre></td></tr></table></figure><h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">垃圾回收参数</span><br><span class="line">-Xnoclassgc 是否对类进行回收</span><br><span class="line">-verbose:class -XX:+TraceClassUnloading 查看类加载和卸载信息</span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio Eden和其中一个survivor的比值</span><br><span class="line">-XX:PretenureSizeThreshold 大对象进入老年代的阈值，Serial和ParNew生效</span><br><span class="line">-XX:MaxTenuringThreshold 晋升老年代的对象年龄，默认15, CMS默认是4</span><br><span class="line">-XX:HandlePromotionFailure 老年代担保</span><br><span class="line">-XX:+UseAdaptiveSizePolicy动态调整Java堆中各个区域大小和进入老年代年龄</span><br><span class="line">-XX:ParallelGCThreads 并行回收的线程数</span><br><span class="line">-XX:MaxGCPauseMillis Parallel Scavenge参数，设置GC的最大停顿时间</span><br><span class="line">-XX:GCTimeRatio  Parallel Scavenge参数，GC时间占总时间的比率，默认99%，即1%的GC时间</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction，old区触发cms阈值，默认68%</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection(CMS完成后是否进行一次碎片整理，停顿时间加长)</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction(执行多少次不进行碎片整理的FullGC后进行一次带压缩的)</span><br><span class="line">-XX:+ScavengeBeforeFullGC，在fullgc前触发一次minorGC</span><br><span class="line"></span><br><span class="line">垃圾回收统计信息</span><br><span class="line">-XX:+PrintGC 输出GC日志</span><br><span class="line">-verbose:gc等同于上面那个</span><br><span class="line">-XX:+PrintGCDetails 输出GC的详细日志</span><br><span class="line"></span><br><span class="line">堆大小设置</span><br><span class="line">-Xmx:最大堆大小</span><br><span class="line">-Xms:初始堆大小(最小内存值)</span><br><span class="line">-Xmn:年轻代大小</span><br><span class="line">-XX:NewSize和-XX:MaxNewSize 新生代大小</span><br><span class="line">-XX:SurvivorRatio:3 意思是年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</span><br><span class="line">-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5</span><br><span class="line">-Xss栈容量 默认256k</span><br><span class="line">-XX:PermSize永久代初始值</span><br><span class="line">-XX:MaxPermSize 永久代最大值</span><br></pre></td></tr></table></figure><p>生产环境参数配置(CMS-GC)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Java &lt; 8</span><br><span class="line">    -server</span><br><span class="line">    -Xms&lt;heap size&gt;[g|m|k] -Xmx&lt;heap size&gt;[g|m|k]</span><br><span class="line">    -XX:PermSize=&lt;perm gen size&gt;[g|m|k] -XX:MaxPermSize=&lt;perm gen size&gt;[g|m|k]</span><br><span class="line">    -Xmn&lt;young size&gt;[g|m|k]</span><br><span class="line">    -XX:+DisableExplicitGC</span><br><span class="line">    -XX:SurvivorRatio=&lt;ratio&gt;</span><br><span class="line">    -XX:+UseConcMarkSweepGC </span><br><span class="line">    -XX:+CMSParallelRemarkEnabled</span><br><span class="line">    -XX:+CMSScavengeBeforeRemark</span><br><span class="line">    -XX:+UseCMSInitiatingOccupancyOnly </span><br><span class="line">    -XX:CMSInitiatingOccupancyFraction=&lt;percent&gt;</span><br><span class="line">    -XX:+PrintGCDateStamps -verbose:gc -XX:+PrintGCDetails -Xloggc:&quot;&lt;path to log&gt;&quot;</span><br><span class="line">    -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M</span><br><span class="line">    -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=&lt;path to dump&gt;`date`.hprof</span><br><span class="line">    -Dsun.net.inetaddr.ttl=&lt;TTL in seconds&gt;</span><br><span class="line">    -Djava.rmi.server.hostname=&lt;external IP&gt;</span><br><span class="line">    -Dcom.sun.management.jmxremote.port=&lt;port&gt; </span><br><span class="line">    -Dcom.sun.management.jmxremote.authenticate=false </span><br><span class="line">    -Dcom.sun.management.jmxremote.ssl=false</span><br><span class="line"></span><br><span class="line">Java &gt;= 8</span><br><span class="line">    -server</span><br><span class="line">    -Xms&lt;heap size&gt;[g|m|k] -Xmx&lt;heap size&gt;[g|m|k]</span><br><span class="line">    -XX:MaxMetaspaceSize=&lt;metaspace size&gt;[g|m|k]</span><br><span class="line">    -Xmn&lt;young size&gt;[g|m|k]</span><br><span class="line">    -XX:+DisableExplicitGC</span><br><span class="line">    -XX:SurvivorRatio=&lt;ratio&gt;</span><br><span class="line">    -XX:+UseConcMarkSweepGC </span><br><span class="line">    -XX:+CMSParallelRemarkEnabled</span><br><span class="line">    -XX:+CMSScavengeBeforeRemark</span><br><span class="line">    -XX:+UseCMSInitiatingOccupancyOnly</span><br><span class="line">    -XX:CMSInitiatingOccupancyFraction=&lt;percent&gt;</span><br><span class="line">    -XX:+PrintGCDateStamps -verbose:gc -XX:+PrintGCDetails -Xloggc:&quot;&lt;path to log&gt;&quot;</span><br><span class="line">    -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M</span><br><span class="line">    -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=&lt;path to dump&gt;`date`.hprof</span><br><span class="line">    -Dsun.net.inetaddr.ttl=&lt;TTL in seconds&gt;</span><br><span class="line">    -Djava.rmi.server.hostname=&lt;external IP&gt;</span><br><span class="line">    -Dcom.sun.management.jmxremote.port=&lt;port&gt; </span><br><span class="line">    -Dcom.sun.management.jmxremote.authenticate=false </span><br><span class="line">    -Dcom.sun.management.jmxremote.ssl=false</span><br></pre></td></tr></table></figure><h2 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DefNew：Serial收集器新生代名称 - Tenured - Perm</span><br><span class="line">ParNew：ParNew收集器新生代名称 - </span><br><span class="line">PSYoungGen：Parallel Scavenge收集器新生代名称</span><br></pre></td></tr></table></figure><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><ul><li>GC的时间足够的小</li><li>GC的次数足够的少</li><li><p>发生Full GC的周期足够的长</p><p>前两个目前是相悖的，要想GC时间小必须要一个更小的堆，要保证GC次数足够少，必须保证一个更大的堆，我们只能取其平衡。</p></li></ul><p>（1）针对JVM堆的设置，一般可以通过-Xms -Xmx限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，我们通常把最大、最小设置为相同的值</p><p>（2）年轻代和年老代将根据默认的比例（1：2）分配堆内存，可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代，比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小。-XX:PermSize，-XX:MaxPermSize设置为一样防止老年代收缩。<br>-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5<br>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</p><p>（3）年轻代和年老代设置多大才算合理？这个我问题毫无疑问是没有答案的，否则也就不会有调优。我们观察一下二者大小变化有哪些影响<br>年轻代老年代设置：整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐年轻代配置为整个堆的3/8。</p><ul><li>更大的年轻代必然导致更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC</li><li>更小的年轻代必然导致更大年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率</li><li>如何选择应该依赖应用程序对象生命周期的分布情况：如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。但很多应用都没有这样明显的特性，在抉择时应该根据以下两点：（A）本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理 （B）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间</li></ul><p>（4）在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC ，默认为Serial收集</p><p>（5）线程堆栈的设置：每个线程默认会开启1M的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般256K就足用。理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。 -Xss256k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p><p>（6）可以通过下面的参数打Heap Dump信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:HeapDumpPath</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-Xloggc:/usr/aaa/dump/heap_trace.txt</span><br><span class="line">通过下面参数可以控制OutOfMemoryError时打印堆的信息</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure><p>注：通过分析dump文件可以发现，每个1小时都会发生一次Full GC，经过多方求证，只要在JVM中开启了JMX服务，JMX将会1小时执行一次Full GC以清除引用.</p><h2 id="性能分析工具"><a href="#性能分析工具" class="headerlink" title="性能分析工具"></a>性能分析工具</h2><p>jps<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-m 主类的参数 </span><br><span class="line">-l 主类的全名，如果执行的是jar包，输出jar路径</span><br><span class="line">-v 虚拟机参数</span><br></pre></td></tr></table></figure><p></p><p>jstat<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">监视虚拟机运行状态信息，包括类装载、GC、运行期编译（JIT）</span><br><span class="line">用于输出java程序内存使用情况，包括新生代、老年代、元数据区容量、垃圾回收情况</span><br><span class="line"> jstat -gcutil 52670 2000 5 进程号 2s输出一次一共5次</span><br><span class="line"></span><br><span class="line">S0：幸存1区当前使用比例</span><br><span class="line">S1：幸存2区当前使用比例</span><br><span class="line">E：伊甸园区使用比例</span><br><span class="line">O：老年代使用比例</span><br><span class="line">M：元数据区使用比例</span><br><span class="line">CCS：压缩使用比例</span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line">YGCT：年轻代垃圾回收消耗时间</span><br><span class="line">FGC：老年代垃圾回收次数</span><br><span class="line">FGCT：老年代垃圾回收消耗时间</span><br><span class="line">GCT：垃圾回收消耗总时间</span><br></pre></td></tr></table></figure><p></p><p>jmap<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jmap：用于生成堆转储快照。一般称为dump或heapdump文件。</span><br><span class="line">jmap -histo 3618</span><br><span class="line">上述命令打印出进程ID为3618的内存情况，包括有哪些对象，对象的数量。但我们常用的方式是将指定进程的内存heap输出到外              部文件，再由专门的heap分析工具进行分析,例如mat（Memory Analysis Tool），所以我们常用的命令是：</span><br><span class="line">jmap -dump:live,format=b,file=heap.hprof 3618</span><br><span class="line">-F 强制生成dump快照</span><br></pre></td></tr></table></figure><p></p><p>jstack<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jstack：用户输出虚拟机当前时刻的线程快照，常用于定位因为某些线程问题造成的故障或性能问题。一般称为threaddump文件。</span><br><span class="line">参数</span><br><span class="line">-F当正常输出没有响应的时候强制打印栈信息，一般情况不需要使用</span><br><span class="line">-l长列表. 打印关于锁的附加信息，一般情况不需要使用</span><br><span class="line">-m 如果调用本地方法的话，可打印c/c++的堆栈</span><br></pre></td></tr></table></figure><p></p><p>jinfo</p><p>查看和修改虚拟机参数</p><p>可视化工具<br>JConsole Java监视与管理控制台<br>VisualVM 多合一故障处理工具</p><p>Java Class文件类型前缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Element Type        Encoding</span><br><span class="line">boolean             Z</span><br><span class="line">byte                B</span><br><span class="line">char                C</span><br><span class="line">double              D</span><br><span class="line">float               F</span><br><span class="line">int                 I</span><br><span class="line">long                J</span><br><span class="line">short               S </span><br><span class="line">class or interface  Lclassname;</span><br><span class="line">[L代表了相应类型数组嵌套的层数</span><br></pre></td></tr></table></figure><h2 id="内存泄漏及解决方法"><a href="#内存泄漏及解决方法" class="headerlink" title="内存泄漏及解决方法"></a>内存泄漏及解决方法</h2><p>1.系统崩溃前的一些现象：</p><p>每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，FullGC的时间也有之前的0.5s延长到4、5s</p><p>FullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC</p><p>年老代的内存越来越大并且每次FullGC后年老代没有内存被释放</p><p>之后系统会无法响应新的请求，逐渐到达OutOfMemoryError的临界值。</p><p>2.生成堆的dump文件<br>通过JMX的MBean生成当前的Heap信息，大小为一个3G（整个堆的大小）的hprof文件，如果没有启动JMX可以通过Java的jmap命令来生成该文件。</p><p>3.分析dump文件</p><p>下面要考虑的是如何打开这个3G的堆信息文件，显然一般的Window系统没有这么大的内存，必须借助高配置的Linux。当然我们可以借助X-Window把Linux上的图形导入到Window。我们考虑用下面几种工具打开该文件：</p><p>1.Visual VM<br>2.IBM HeapAnalyzer<br>3.JDK 自带的Hprof工具</p><p>使用这些工具时为了确保加载速度，建议设置最大内存为6G。使用后发现，这些工具都无法直观地观察到内存泄漏，Visual VM虽能观察到对象大小，但看不到调用堆栈；HeapAnalyzer虽然能看到调用堆栈，却无法正确打开一个3G的文件。因此，我们又选用了Eclipse专门的静态内存分析工具：Mat。</p><p>4.分析内存泄漏</p><p>通过Mat我们能清楚地看到，哪些对象被怀疑为内存泄漏，哪些对象占的空间最大及对象的调用关系。针对本案，在ThreadLocal中有很多的JbpmContext实例，经过调查是JBPM的Context没有关闭所致。</p><p>另，通过Mat或JMX我们还可以分析线程状态，可以观察到线程被阻塞在哪个对象上，从而判断系统的瓶颈。</p><p>5.回归问题</p><p>Q：为什么崩溃前垃圾回收的时间越来越长？</p><p>A:根据内存模型和垃圾回收算法，垃圾回收分两部分：内存标记、清除（复制），标记部分只要内存大小固定，时间是不变的，变的是复制部分，因为每次垃圾回收都有一些回收不掉的内存，所以增加了复制量，导致时间延长。所以，垃圾回收的时间也可以作为判断内存泄漏的依据</p><p>Q：为什么Full GC的次数越来越多？</p><p>A：因此内存的积累，逐渐耗尽了年老代的内存，导致新对象分配没有更多的空间，从而导致频繁的垃圾回收</p><p>Q:为什么年老代占用的内存越来越大？</p><p>A:因为年轻代的内存无法被回收，越来越多地被Copy到年老代</p><h2 id="调优方法"><a href="#调优方法" class="headerlink" title="调优方法"></a>调优方法</h2><p>一切都是为了这一步，调优，在调优之前，我们需要记住下面的原则：</p><p>1、多数的Java应用不需要在服务器上进行GC优化；</p><p>2、多数导致GC问题的Java应用，都不是因为我们参数设置错误，而是代码问题；</p><p>3、在应用上线之前，先考虑将机器的JVM参数设置到最优（最适合）</p><p>4、减少创建对象的数量；</p><p>5、减少使用全局变量和大对象；</p><p>6、GC优化是到最后不得已才采用的手段；</p><p>7、在实际使用中，分析GC情况优化代码比优化GC参数要多得多；</p><p>GC优化的目的有两个</p><p>1、将转移到老年代的对象数量降低到最小；</p><p>2、减少full GC的执行时间；</p><p>为了达到上面的目的，一般地，你需要做的事情有：</p><p>1、减少使用全局变量和大对象；</p><p>2、调整新生代的大小到最合适；</p><p>3、设置老年代的大小为最合适；</p><p>4、选择合适的GC收集器</p></div><div><div style="text-align:center;color:#ccc;font-size:14px">------ 本文结束<i class="fa fa-paw"></i>感谢您的阅读 ------</div></div><div></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/03/22/rabbitmq/" rel="next" title="rabbitmq"><i class="fa fa-chevron-left"></i> rabbitmq</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/03/25/java面试题/" rel="prev" title="java面试题梳理">java面试题梳理 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/pic.jpg" alt="Dnight"><p class="site-author-name" itemprop="name">Dnight</p><p class="site-description motion-element" itemprop="description">菜鸡之路</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">1</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">5</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/rss2.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zhong2peng" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://weibo.com/3760833981" target="_blank" title="微博"><i class="fa fa-fw fa-weibo"></i>微博</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://www.tianxiaobo.com/" title="田小波" target="_blank">田小波</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM-内存结构"><span class="nav-number">1.</span> <span class="nav-text">JVM 内存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#程序计数器（PC-寄存器）"><span class="nav-number">1.1.</span> <span class="nav-text">程序计数器（PC 寄存器）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序计数器的定义"><span class="nav-number">1.1.1.</span> <span class="nav-text">程序计数器的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序计数器的作用"><span class="nav-number">1.1.2.</span> <span class="nav-text">程序计数器的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序计数器的特点"><span class="nav-number">1.1.3.</span> <span class="nav-text">程序计数器的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-虚拟机栈（Java-栈）"><span class="nav-number">1.2.</span> <span class="nav-text">Java 虚拟机栈（Java 栈）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-虚拟机栈的定义"><span class="nav-number">1.2.1.</span> <span class="nav-text">Java 虚拟机栈的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#压栈出栈过程"><span class="nav-number">1.2.2.</span> <span class="nav-text">压栈出栈过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-虚拟机栈的特点"><span class="nav-number">1.2.3.</span> <span class="nav-text">Java 虚拟机栈的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本地方法栈（C-栈）"><span class="nav-number">1.3.</span> <span class="nav-text">本地方法栈（C 栈）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#本地方法栈的定义"><span class="nav-number">1.3.1.</span> <span class="nav-text">本地方法栈的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈帧变化过程"><span class="nav-number">1.3.2.</span> <span class="nav-text">栈帧变化过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆"><span class="nav-number">1.4.</span> <span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#堆的定义"><span class="nav-number">1.4.1.</span> <span class="nav-text">堆的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆的特点"><span class="nav-number">1.4.2.</span> <span class="nav-text">堆的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法区"><span class="nav-number">1.5.</span> <span class="nav-text">方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法区的定义"><span class="nav-number">1.5.1.</span> <span class="nav-text">方法区的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法区的特点"><span class="nav-number">1.5.2.</span> <span class="nav-text">方法区的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时常量池"><span class="nav-number">1.5.3.</span> <span class="nav-text">运行时常量池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#直接内存（堆外内存）"><span class="nav-number">1.6.</span> <span class="nav-text">直接内存（堆外内存）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#操作直接内存"><span class="nav-number">1.6.1.</span> <span class="nav-text">操作直接内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#直接内存与堆内存比较"><span class="nav-number">1.6.2.</span> <span class="nav-text">直接内存与堆内存比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HotSpot-虚拟机对象探秘"><span class="nav-number">2.</span> <span class="nav-text">HotSpot 虚拟机对象探秘</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的内存布局"><span class="nav-number">2.1.</span> <span class="nav-text">对象的内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象头"><span class="nav-number">2.1.1.</span> <span class="nav-text">对象头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例数据"><span class="nav-number">2.1.2.</span> <span class="nav-text">实例数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对齐填充"><span class="nav-number">2.1.3.</span> <span class="nav-text">对齐填充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的创建过程"><span class="nav-number">2.2.</span> <span class="nav-text">对象的创建过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载检查"><span class="nav-number">2.2.1.</span> <span class="nav-text">类加载检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为新生对象分配内存"><span class="nav-number">2.2.2.</span> <span class="nav-text">为新生对象分配内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">2.2.3.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的访问方式"><span class="nav-number">2.3.</span> <span class="nav-text">对象的访问方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#句柄访问方式"><span class="nav-number">2.3.1.</span> <span class="nav-text">句柄访问方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#直接指针访问方式"><span class="nav-number">2.3.2.</span> <span class="nav-text">直接指针访问方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#垃圾收集策略与算法"><span class="nav-number">3.</span> <span class="nav-text">垃圾收集策略与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#判定对象是否存活"><span class="nav-number">3.1.</span> <span class="nav-text">判定对象是否存活</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引用计数法"><span class="nav-number">3.1.1.</span> <span class="nav-text">引用计数法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可达性分析法"><span class="nav-number">3.1.2.</span> <span class="nav-text">可达性分析法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用的种类"><span class="nav-number">3.2.</span> <span class="nav-text">引用的种类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#强引用（Strong-Reference）"><span class="nav-number">3.2.1.</span> <span class="nav-text">强引用（Strong Reference）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软引用（Soft-Reference）"><span class="nav-number">3.2.2.</span> <span class="nav-text">软引用（Soft Reference）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#弱引用（Weak-Reference）"><span class="nav-number">3.2.3.</span> <span class="nav-text">弱引用（Weak Reference）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚引用（Phantom-Reference）"><span class="nav-number">3.2.4.</span> <span class="nav-text">虚引用（Phantom Reference）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回收堆中无效对象"><span class="nav-number">3.3.</span> <span class="nav-text">回收堆中无效对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#判定-finalize-是否有必要执行"><span class="nav-number">3.3.1.</span> <span class="nav-text">判定 finalize() 是否有必要执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象重生或死亡"><span class="nav-number">3.3.2.</span> <span class="nav-text">对象重生或死亡</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回收方法区内存"><span class="nav-number">3.4.</span> <span class="nav-text">回收方法区内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#判定废弃常量"><span class="nav-number">3.4.1.</span> <span class="nav-text">判定废弃常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判定无用的类"><span class="nav-number">3.4.2.</span> <span class="nav-text">判定无用的类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集算法"><span class="nav-number">3.5.</span> <span class="nav-text">垃圾收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标记-清除算法"><span class="nav-number">3.5.1.</span> <span class="nav-text">标记-清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制算法（新生代）"><span class="nav-number">3.5.2.</span> <span class="nav-text">复制算法（新生代）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分配担保"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">分配担保</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标记-整理算法（老年代）"><span class="nav-number">3.5.3.</span> <span class="nav-text">标记-整理算法（老年代）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分代收集算法"><span class="nav-number">3.5.4.</span> <span class="nav-text">分代收集算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java虚拟机"><span class="nav-number">4.</span> <span class="nav-text">Java虚拟机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集器"><span class="nav-number">4.1.</span> <span class="nav-text">垃圾收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#收集器组合开关选项"><span class="nav-number">4.2.</span> <span class="nav-text">收集器组合开关选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM参数"><span class="nav-number">4.3.</span> <span class="nav-text">JVM参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#理解GC日志"><span class="nav-number">4.4.</span> <span class="nav-text">理解GC日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM调优"><span class="nav-number">4.5.</span> <span class="nav-text">JVM调优</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能分析工具"><span class="nav-number">4.6.</span> <span class="nav-text">性能分析工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄漏及解决方法"><span class="nav-number">4.7.</span> <span class="nav-text">内存泄漏及解决方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调优方法"><span class="nav-number">4.8.</span> <span class="nav-text">调优方法</span></a></li></ol></li></ol></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Dnight</span></div><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div><div class="busuanzi-count"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i> <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="site-pv"><i class="fa fa-eye"></i> <span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/three/three.min.js"></script><script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script>AV.initialize("oJM2KP9949u790dn1g3FVavc-gzGzoHsz","gPtQOls39Fh76goU0K9oj5tw")</script><script>function showTime(e){var t=new AV.Query(e),n=[],o=$(".leancloud_visitors");o.each(function(){n.push($(this).attr("id").trim())}),t.containedIn("url",n),t.find().done(function(e){var t=".leancloud-visitors-count";if(0===e.length)return void o.find(t).text(0);for(var i=0;i<e.length;i++){var r=e[i],s=r.get("url"),l=r.get("time"),c=document.getElementById(s);$(c).find(t).text(l)}for(var i=0;i<n.length;i++){var s=n[i],c=document.getElementById(s),u=$(c).find(t);""==u.text()&&u.text(0)}}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var t=$(".leancloud_visitors"),n=t.attr("id").trim(),o=t.attr("data-flag-title").trim(),i=new AV.Query(e);i.equalTo("url",n),i.find({success:function(t){if(t.length>0){var i=t[0];i.fetchWhenSave(!0),i.increment("time"),i.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var r=new e,s=new AV.ACL;s.setPublicReadAccess(!0),s.setPublicWriteAccess(!0),r.setACL(s),r.set("title",o),r.set("url",n),r.set("time",1),r.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):$(".post-title-link").length>1&&showTime(e)})</script></body></html><!-- rebuild by neat -->